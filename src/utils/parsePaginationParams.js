const parseNumber = (number, defaultValue) => {
  const isString = typeof number === "string";
  if (!isString) return defaultValue;

  const parsedNumber = parseInt(number);
  if (Number.isNaN(parsedNumber)) {
    return defaultValue;
  }

  return parsedNumber;
};

// Функція parseNumber призначена для перетворення рядкових значень в числа і
// є особливо корисною в контекстах, де ми не можемо бути впевнені у типі даних,
// що надходять.Вона приймає два параметри: number, що є значенням для перетворення,
// та defaultValue, яке використовується як запасне, якщо перетворення неможливе.

// Перш за все, функція перевіряє, чи є передане значення рядком. Якщо це не так,
// вона одразу повертає значення за замовчуванням.Якщо ж значення є рядком, вона
// спробує перетворити його на число.Якщо результат перетворення є NaN(не число),
// повертається значення за замовчуванням.

// У випадку успішного перетворення, функція повертає це число.

export const parsePaginationParams = (query) => {
  const { page, perPage } = query;

  const parsedPage = parseNumber(page, 1);
  const parsedPerPage = parseNumber(perPage, 10);

  return {
    page: parsedPage,
    perPage: parsedPerPage,
  };
};

// Функція parsePaginationParams використовує parseNumber для обробки пагінаційних
// параметрів, які зазвичай надходять у запитах до бекенду.Ці параметри, page і perPage,
// містяться в об'єкті query і можуть бути неправильно вказані або взагалі пропущені.

// Функція спершу витягує ці параметри, а потім використовує parseNumber для їх валідації
// та конвертації, зі значеннями за замовчуванням 1 для page і 10 для perPage.

// Кінцевим результатом є об'єкт з коректно обробленими і валідними пагінаційними параметрами.

// Тепер, користуючись цим парсером, ми можемо отримати значення page та perPage і передати
// їх далі до обробки в контролери:
